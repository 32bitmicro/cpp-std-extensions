
== `utility.hpp`

`overload` is a struct designed to encapsulate an overload set. It inherits from
all the lambda expressions used to construct it. As an example, it's useful for
visiting a variant.

[source,cpp]
----
auto f(std::variant<int, float, std::string> const& v) {
  return std::visit(
    stdx::overload{
      [] (std::string const& s) { return s; },
      [] (auto num) { return std::to_string(num); }
    }, v);
}
----

`unreachable` is an implementation of
https://en.cppreference.com/w/cpp/utility/unreachable[`std::unreachable`].

[source,cpp]
----
[[noreturn]] inline auto unreachable() -> void {
  // if this function is ever called, it's
  // undefined behaviour
}
----

`utility.hpp` also contains a few handy user-defined literals so that code using
boolean values can be more expressive at the call site than just using bare
`true` and `false`. This also makes it safer to use templates with `bool`
parameters.

[source,cpp]
----
using namespace stdx::literals;

template <bool X>
struct my_type { ... };

using my_type_with_X = my_type<"X"_true>;
using my_type_without_X = my_type<"X"_false>;

using my_type_with_X_alt = my_type<"X"_b>;
using my_type_without_X_alt = my_type<not "X"_b>;
----
